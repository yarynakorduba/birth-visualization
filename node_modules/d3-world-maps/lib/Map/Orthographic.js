'use strict';

Object.defineProperty(exports, '__esModule', {
  value: true
});

var _createClass = (function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ('value' in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; })();

var _get = function get(_x, _x2, _x3) { var _again = true; _function: while (_again) { var object = _x, property = _x2, receiver = _x3; _again = false; if (object === null) object = Function.prototype; var desc = Object.getOwnPropertyDescriptor(object, property); if (desc === undefined) { var parent = Object.getPrototypeOf(object); if (parent === null) { return undefined; } else { _x = parent; _x2 = property; _x3 = receiver; _again = true; desc = parent = undefined; continue _function; } } else if ('value' in desc) { return desc.value; } else { var getter = desc.get; if (getter === undefined) { return undefined; } return getter.call(receiver); } } };

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError('Cannot call a class as a function'); } }

function _inherits(subClass, superClass) { if (typeof superClass !== 'function' && superClass !== null) { throw new TypeError('Super expression must either be null or a function, not ' + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

var _Projection2 = require('./Projection');

var _Projection3 = _interopRequireDefault(_Projection2);

var _d3 = require('d3');

var _d32 = _interopRequireDefault(_d3);

var _jquery = require('jquery');

var _jquery2 = _interopRequireDefault(_jquery);

var radians = Math.PI / 180;
var degrees = 180 / Math.PI;
/**
 * Orthographic Projection Class
 * @class
 */

var Orthographic = (function (_Projection) {
  _inherits(Orthographic, _Projection);

  /**
   * @constructor
   */

  function Orthographic(group, svg, options) {
    _classCallCheck(this, Orthographic);

    _get(Object.getPrototypeOf(Orthographic.prototype), 'constructor', this).call(this, group, _d32['default'].geo.orthographic().clipAngle(90), svg);
    this.prjFnc.rotate([0, 0]);
    this.setScale();
    this.zoom.scaleExtent([150, 600]);
    this.projectionType = 'Orthographic';
    this.zoomPoint = null;
    this.initOrth();
  }

  _createClass(Orthographic, [{
    key: 'initOrth',
    value: function initOrth() {
      (0, _jquery2['default'])('.graticule_orth').css('display', 'block');
      (0, _jquery2['default'])('.graticule_mer').css('display', 'none');
    }

    /**
     * Sets projection scale based on dimensions
     * @method
     */
  }, {
    key: 'setScale',
    value: function setScale() {
      if (this.height >= this.width) {
        this.zoom.scale(this.width / 2);
        this.prjFnc.scale(this.width / 2);
      } else {
        this.zoom.scale(this.height / 2 - this.height * 0.05);
        this.prjFnc.scale(this.height / 2 - this.height * 0.05);
      }
      this.prjFnc.translate([this.width / 2, this.height / 2]);
    }

    /**
     * Collects Zoom Event properties
     * @method
     */
  }, {
    key: 'onZoomStart',
    value: function onZoomStart() {
      this.mouse0 = _d32['default'].mouse(this.group[0][0]);
      this.rotate = this.quaternionFromEuler(this.prjFnc.rotate());
      this.point = this.position(this.prjFnc, this.mouse0);
      if (this.point) {
        this.zoomPoint = this.point;
      }
    }

    /**
     * Updates projection after drag
     * @method
     */
  }, {
    key: 'onZoom',
    value: function onZoom() {
      this.prjFnc.scale(_d32['default'].event.scale);
      var mouse1 = _d32['default'].mouse(this.group[0][0]);
      var between = this.rotateBetween(this.zoomPoint, this.position(this.prjFnc, mouse1));
      this.prjFnc.rotate(this.eulerFromQuaternion(this.rotate = between ? this.multiply(this.rotate, between) : this.multiply(this.bank(this.prjFnc, this.mouse0, mouse1), this.rotate)));
      this.mouse0 = mouse1;
      this.redraw();
    }

    /**
     * Determines appropriate scale and Translate of an onClick Zoom
     * @method
     * @param {string} inOrOut - Variable that says whether to zoom in or out
     */
  }, {
    key: 'zoomClick',
    value: function zoomClick(inOrOut) {
      var direction = 1,
          factor = 30,
          targetZoom = 1,
          extent = this.zoom.scaleExtent();
      direction = inOrOut === 'zoom_in' ? 1 : -1;
      targetZoom = this.zoom.scale() + factor * direction;
      if (targetZoom < extent[0] || targetZoom > extent[1]) {
        return false;
      }
      this.interpolateZoom(targetZoom);
    }

    /**
     * Zoom Interpolation Function
     * @method
     * @param {string} scale - New Scale
     */
  }, {
    key: 'interpolateZoom',
    value: function interpolateZoom(scale) {
      var self = this;
      return _d32['default'].transition().duration(350).tween('zoom', function () {
        var iScale = _d32['default'].interpolate(self.zoom.scale(), scale);
        return function (t) {
          self.zoom.scale(iScale(t));
          self.zoomed();
        };
      });
    }

    /**
     * Rescales Zoom and Updates paths
     * @method
     */
  }, {
    key: 'zoomed',
    value: function zoomed() {
      this.prjFnc.scale(this.zoom.scale());
      this.redraw();
    }

    /**
     * Todo
     * @method
     */
  }, {
    key: 'bank',
    value: function bank(projection, p0, p1) {
      var t = projection.translate(),
          angle = Math.atan2(p0[1] - t[1], p0[0] - t[0]) - Math.atan2(p1[1] - t[1], p1[0] - t[0]);
      return [Math.cos(angle / 2), 0, 0, Math.sin(angle / 2)];
    }

    /**
     * Todo
     * @method
     */
  }, {
    key: 'position',
    value: function position(projection, point) {

      projection.translate();
      var spherical = projection.invert(point);

      return spherical && isFinite(spherical[0]) && isFinite(spherical[1]) && this.cartesian(spherical);
    }

    /**
     * Todo
     * @method
     */
  }, {
    key: 'quaternionFromEuler',
    value: function quaternionFromEuler(euler) {
      var λ = .5 * euler[0] * radians;
      var φ = .5 * euler[1] * radians;
      var γ = .5 * euler[2] * radians,
          sinλ = Math.sin(λ),
          cosλ = Math.cos(λ),
          sinφ = Math.sin(φ),
          cosφ = Math.cos(φ),
          sinγ = Math.sin(γ),
          cosγ = Math.cos(γ);
      return [cosλ * cosφ * cosγ + sinλ * sinφ * sinγ, sinλ * cosφ * cosγ - cosλ * sinφ * sinγ, cosλ * sinφ * cosγ + sinλ * cosφ * sinγ, cosλ * cosφ * sinγ - sinλ * sinφ * cosγ];
    }

    /**
     * Todo
     * @method
     */
  }, {
    key: 'multiply',
    value: function multiply(a, b) {
      var a0 = a[0],
          a1 = a[1],
          a2 = a[2],
          a3 = a[3];
      var b0 = b[0],
          b1 = b[1],
          b2 = b[2],
          b3 = b[3];
      return [a0 * b0 - a1 * b1 - a2 * b2 - a3 * b3, a0 * b1 + a1 * b0 + a2 * b3 - a3 * b2, a0 * b2 - a1 * b3 + a2 * b0 + a3 * b1, a0 * b3 + a1 * b2 - a2 * b1 + a3 * b0];
    }

    /**
     * Todo
     * @method
     */
  }, {
    key: 'rotateBetween',
    value: function rotateBetween(a, b) {
      if (!a || !b) {
        return null;
      }
      var axis = this.cross(a, b);
      var self = this;
      var norm = Math.sqrt(self.dot(axis, axis));
      var halfγ = .5 * Math.acos(Math.max(-1, Math.min(1, self.dot(a, b))));
      var k = Math.sin(halfγ) / norm;

      return norm && [Math.cos(halfγ), axis[2] * k, -axis[1] * k, axis[0] * k];
    }

    /**
     * Todo
     * @method
     */
  }, {
    key: 'eulerFromQuaternion',
    value: function eulerFromQuaternion(q) {
      return [Math.atan2(2 * (q[0] * q[1] + q[2] * q[3]), 1 - 2 * (q[1] * q[1] + q[2] * q[2])) * degrees, Math.asin(Math.max(-1, Math.min(1, 2 * (q[0] * q[2] - q[3] * q[1])))) * degrees, Math.atan2(2 * (q[0] * q[3] + q[1] * q[2]), 1 - 2 * (q[2] * q[2] + q[3] * q[3])) * degrees];
    }

    /**
     * Todo
     * @method
     */
  }, {
    key: 'cartesian',
    value: function cartesian(spherical) {
      var λ = spherical[0] * radians;
      var φ = spherical[1] * radians,
          cosφ = Math.cos(φ);
      return [cosφ * Math.cos(λ), cosφ * Math.sin(λ), Math.sin(φ)];
    }

    /**
     * Todo
     * @method
     */
  }, {
    key: 'dot',
    value: function dot(a, b) {
      var s = 0;
      for (var i = 0, n = a.length; i < n; ++i) {
        s += a[i] * b[i];
      }
      return s;
    }

    /**
     * Todo
     * @method
     */
  }, {
    key: 'cross',
    value: function cross(a, b) {
      return [a[1] * b[2] - a[2] * b[1], a[2] * b[0] - a[0] * b[2], a[0] * b[1] - a[1] * b[0]];
    }
  }]);

  return Orthographic;
})(_Projection3['default']);

exports['default'] = Orthographic;
module.exports = exports['default'];