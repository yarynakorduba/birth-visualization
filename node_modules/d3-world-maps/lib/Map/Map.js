'use strict';

Object.defineProperty(exports, '__esModule', {
  value: true
});

var _createClass = (function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ('value' in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; })();

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError('Cannot call a class as a function'); } }

var _assetsTopo_countriesJson = require('../../assets/topo_countries.json');

var _assetsTopo_countriesJson2 = _interopRequireDefault(_assetsTopo_countriesJson);

var _d3 = require('d3');

var _d32 = _interopRequireDefault(_d3);

var _topojson = require('topojson');

var _topojson2 = _interopRequireDefault(_topojson);

var _Mercator = require('./Mercator');

var _Mercator2 = _interopRequireDefault(_Mercator);

var _Orthographic = require('./Orthographic');

var _Orthographic2 = _interopRequireDefault(_Orthographic);

var _options = require('./options');

var _options2 = _interopRequireDefault(_options);

var _jquery = require('jquery');

var _jquery2 = _interopRequireDefault(_jquery);

var PROJECTIONS = {
  Mercator: _Mercator2['default'],
  Orthographic: _Orthographic2['default']
};

/**
 * Creates a new Map.
 * @class
 */

var WorldMap = (function () {
  /**
   * @constructor
   */

  function WorldMap(options) {
    _classCallCheck(this, WorldMap);

    this.options = _jquery2['default'].extend(_options2['default'], options);
    this.el = this.options.el;
    this.pointRadius = this.options.pointRadius || 0.5;
    this.projectionType = this.options.projection;
    this.landFill = this.options.landFill;
    this.oceanFill = this.options.oceanFill;
    //this.scaleLimits = this.options.scaleLimits;
    this.countries = _topojson2['default'].feature(_assetsTopo_countriesJson2['default'], _assetsTopo_countriesJson2['default'].objects.countries);
    this.inited = false;
  }

  /**
   * Initializes the map
   * @Method
   */

  _createClass(WorldMap, [{
    key: 'init',
    value: function init() {
      this.mapDiv = _d32['default'].select(this.el);
      if (!this.mapDiv) {
        throw new Error('Must create an element with a ' + this.el + ' element to create the SVG');
      }
      this.svg = this.mapDiv.append('svg').attr('class', 'mapsvg');
      this.setDimensions(this.el);
      this.group = this.svg.append('g').attr('class', 'country-group');
      this.graticuleGroup = this.group.append('g').attr('class', 'grat_group');
      this.paths = this.group.append('g').selectAll('path').data(this.countries.features).enter().append('path').attr('id', function (d) {
        return d.properties.n;
      }).attr('class', 'land').style('fill', this.landFill);
      this.createGraticules(this.graticuleGroup);
      this.setProjection(this.projectionType);

      /**
       * Creating group containers for Map elements
       */
      if (this.options.overlay) {
        this.overlay = this.group.append('g').attr('class', 'overlays');
      }
      if (this.options.bubbles) {
        this.bubbles = this.group.append('g').attr('class', 'points');
      }
      if (this.options.locationPins) {
        this.locationPins = this.group.append('g');
        this.setPoints(this.options.locationPins, this.locationPins);
        this.projection.collectPaths();
        this.projection.redraw();
      }
      this.inited = true;
    }

    /**
     * Sets projection of Map.
     * @method
     * @param {string} projection - Map Projection.
     */
  }, {
    key: 'setProjection',
    value: function setProjection(projection) {
      if (this.projection) {
        this.projection.destroy();
      }
      this.projection = new PROJECTIONS[projection](this.group, this.svg, this.options);
      this.projection.redraw();
    }

    /**
     * Sets projection of Map.
     * @method
     * creates a graticle for  Mercator & Orthographic Projections
     */
  }, {
    key: 'createGraticules',
    value: function createGraticules(group) {
      var graticuleOrth = _d32['default'].geo.graticule().extent([[-179.9999, -79.999], [179.999, 79.999]]);
      var graticuleMer = _d32['default'].geo.graticule();
      group.append('path').datum(graticuleOrth).attr('class', 'graticule graticule_orth').style('fill', this.oceanFill);
      group.append('path').datum(graticuleOrth.outline()).attr('class', 'outline_orth outline graticule_orth').style('fill', this.oceanFill);
      group.append('path').datum(graticuleMer).attr('class', 'graticule graticule_mer').style('fill', this.oceanFill);
      group.append('path').datum(graticuleMer.outline()).attr('class', 'outline_mer outline graticule_mer').style('fill', this.oceanFill);
    }

    /**
     * Sets the height, width, and margins of the SVG based on window-size.
     * @method
     */
  }, {
    key: 'setDimensions',
    value: function setDimensions(el) {
      this.w = (0, _jquery2['default'])(el).width();
      this.h = (0, _jquery2['default'])(el).height();
      this.svg.attr('height', this.h).attr('width', this.w);
    }

    /**
     * Sets Points on map.
     * @method
     * @param {Object[]} array of points
     */
  }, {
    key: 'setPoints',
    value: function setPoints(points, group) {
      group.selectAll('path').data(points).enter().append('path').attr('class', 'point').style('fill', this.options.pointsFill).attr('opacity', function (d) {
        if (d.opacity) {
          return d.opacity;
        } else {
          return 1;
        }
      }).datum(function (d) {
        if (!d.radius) {
          d.radius = 5;
        }
        return { type: 'Point', coordinates: [d.coords[0], d.coords[1]], radius: d.radius };
      });
    }

    /**
     * Sets Overlay on map.
     * @method
     * @param {JSON} - Topojson to be used on map.
     * @param {Object[]} - Range that will be used to create a color gradient
     * Commming soon
     */
    // setOverlay(yearData, range) {
    //   if(this.overlay){this.destroy('overlay'); }
    //   let color = d3.scale.linear()
    //     .domain(range)
    //     .range(['transparent', this.options.overlayColor]);
    //   let result = JSON.parse(yearData);
    //   let topo = topojson.feature(result, result.objects['filtered-vector']);
    //   this.overlay.selectAll('path')
    //     .data(topo.features)
    //     .enter()
    //     .append('path')
    //     .attr('id', function(d) { return d.properties.id; })
    //     .style('fill', function(d) { return color(d.properties.n); })
    //     .attr('class', 'overlay')
    //     .attr('d', this.projection.pathGenerator);
    // }

  }]);

  return WorldMap;
})();

exports['default'] = WorldMap;
module.exports = exports['default'];